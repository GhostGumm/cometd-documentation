
[[_java_server_services_inherited]]
===== Inherited Services

A CometD inherited service is a Java class that extends the CometD class
+org.cometd.server.AbstractService+, which specifies the Bayeux channels of
interest to the service, and adheres to the contract the +AbstractService+
class defines:

====
[source,java]
----
public class EchoService extends AbstractService                                  <1>
{
    public EchoService(BayeuxServer bayeuxServer)                                 <2>
    {
        super(bayeuxServer, "echo");                                              <3>
        addService("/echo", "processEcho");                                       <4>
    }

    public void processEcho(ServerSession remote, Map<String, Object> data)       <5>
    {
        remote.deliver(getServerSession(), "/echo", data);                        <6>
    }
}
----
====

This is a simple echo service that returns the message sent by the remote
client on channel +/echo+ to the remote client itself. Notice the following:

<1> Extends from +org.cometd.server.AbstractService.+
<2> Creates a constructor that takes a +org.cometd.bayeux.server.BayeuxServer+ object.
<3> Calls the superclass constructor, passing the BayeuxServer object and an
    arbitrary name of the service, in this case "echo".
<4> Subscribes to channel "/echo", and specifies the name of a method that
    must be called when a message arrives to that channel, via +addService(...)+.
<5> Defines a method with the same name specified in (4), and with an appropriate
    signature (see below).
<6> Uses the +org.cometd.bayeux.server.ServerSession+ API to echo the message
    back to that particular client.

The contract that the +BayeuxService+ class requires for callback methods is
that the methods must have one of the following signatures:

TODO: review this, I think the signatures are now different (e.g. no messageId)
====
[source,java]
----
// Obtains the remote session object and the message object
public void processEcho(ServerSession remote, Message message)

// Obtains the remote session object and the message's data object
// (additional message information, such as the channel or the id is lost)
public void processEcho(ServerSession remote, Map<String, Object> data)

// Obtains the remote session object, the channel name, the message object and the message id
public void processEcho(ServerSession remote, String channelName, Message message, String messageId)

// Obtains the remote session object, the channel name, the message's data object and the message id
public void processEcho(ServerSession remote, String channelName, Map<String, Object> data, String messageId)
----
====

Method signatures that take the message's data object (the second and fourth above)
take a +Map<String, Object>+ as parameter type because that is the default
deserialization of a JSON object in Java, but it is possible to specify a custom type,
provided that the JSON object has been converted to an object of the custom Java class,
for example:

====
[source,java]
----
// Obtains the remote session object and a custom message's data object
public void processEcho(ServerSession remote, EchoInfo data)
----
====

see also <<_java_json,the JSON section>> for further information about customizing
serialization and deserialization of JSON objects.

Notice that the channel name specified in the +addService()+ method may be a
wildcard, for example:

====
[source,java]
----
public class BaseballTeamService extends AbstractService
{
    public BaseballTeamService(BayeuxServer bayeux)
    {
        super(bayeux, "baseballTeam");
        addService("/baseball/team/*", "processBaseballTeam");
    }

    public void processBaseballTeam(ServerSession remote, String channelName, Map<String, Object> data, String messageId)
    {
        // Upon receiving a message on channel /baseball/team/*, forward to channel /events/baseball/team/*
        getBayeux().getChannel("/events" + channelName).publish(getServerSession(), data);
    }
}
----
====

Notice also how the first example uses +ServerSession.deliver()+ to send a
message to a particular remote client, while the second uses +ServerChannel.publish()+
to send a message to anyone who subscribes to channel +/events/baseball/team/*+.

Method +addService(...)+ is used to map a server-side channel listener with a
method that is invoked every time a message arrives on the channel.
It is not uncommon that a single service has multiple mappings, and mappings
may be even added and removed dynamically:

====
[source,java]
----
public class GameService extends AbstractService
{
    public GameService(BayeuxServer bayeux)
    {
        super(bayeux, "game");
        addService("/service/game/*", "processGameCommand");
        addService("/game/event", "processGameEvent");
    }

    public void processGameCommand(ServerSession remote, GameCommand command)
    {
        switch (command.getType())
        {
            case GAME_START:
            {
                addService("/game/" + command.getGameId(), "processGame");
                break;
            }
            case GAME_END:
            {
                removeService("/game/" + command.getGameId());
                break;
            }
            ...
        }
    }

    public void processGameEvent(ServerSession remote, GameEvent event)
    {
        ...
    }
}
----
====

Note how mappings can be removed using method +removeService(...)+.

Each time a service instance is created, an associated +LocalSession+ (see also
<<_concepts_sessions,this section>>) is created within the service itself: the
service is a local client.
The +LocalSession+ has an associated +ServerSession+ and as such it is treated
by the server in the same way a remote client (that also creates a
+ServerSession+ within the server) is.
The +LocalSession+ and +ServerSession+ are accessible via the +AbstractService+
methods +getLocalSession()+ and +getServerSession()+ respectively.

Once you have written your Bayeux services it is time to set them up in your
web application, see either <<_java_server_services_integration,the services integration section>>
or <<_java_server_services_integration_spring,the Spring Framework services integration section>>.
