
[[_java_server_services_annotated]]
===== Annotated Client-Side and Server-Side Services

Classes annotated with +@Service+ qualify as annotated services, both on the
client-side and on the server-side.

[[_java_server_services_annotated_server_side]]
===== Server-Side Annotated Services

Server-side services are usually written by extending the +org.cometd.server.AbstractService+
class, and instances of these classes normally have a singleton semantic and
are created and configured at web application startup.

The +org.cometd.server.AbstractService+ class provides (via inheritance) some
facilities that are useful when implementing a service, including access to
the +ServerSession+ associated with the service instance and registration of
methods as a callbacks to receive messages from channels.

Services might depend on other services (for example, a data source to access
the database), and might require lifecycle management (that is, the services
have +start()+/+stop()+ methods that must be invoked at appropriate times).

In services extending +org.cometd.server.AbstractService+, dependency injection
and lifecycle management, previously you had to write the code by hand in
a configuration servlet or configuration listeners.
Now annotated server-side services offer full support for CometD features, and
limited support for dependency injection and lifecycle management via the
+org.cometd.annotation.ServerAnnotationProcessor+ class.

Annotated service instances are stored in the servlet context under the key
that correspond to their full qualified class name.

===== Dependency Injection Support

The CometD project offers limited support for dependency injection, since
normally this is accomplished by other frameworks such as
http://www.springsource.org[Spring], http://code.google.com/p/google-guice[Guice]
or http://cdi-spec.org/[CDI].

In particular, it supports only the injection of the BayeuxServer object on
fields and methods (not on constructors), and performs the injection only if
the injection has not yet been performed.

The reason for this limited support is that the CometD project does not want
to implement and support a generic dependency injection container, but instead
offers a simple integration with existing dependency injection containers and
a minimal support for required CometD objects (such as the BayeuxServer instance).

[cols="1a,1a"]
|===
| Annotated Style
| Inherited Style

|
====
[source,java]
----
@org.cometd.annotation.Service("echoService")
public class EchoService
{
    @javax.inject.Inject
    private BayeuxServer bayeux;
}
----
====

|
====
[source,java]
----
public class EchoService extends AbstractService
{
    public EchoService(BayeuxServer bayeux)
    {
        super(bayeux, "echoService");
    }
}
----
====
|===

The service class is annotated with +@Service+ and specifies the (optional)
service name "echoService". The BayeuxServer field is annotated with the
standard http://jcp.org/en/jsr/detail?id=330[JSR 330] +@Inject+ annotation.
The +@Inject+ annotation is supported (for example, by Spring 3.x) for
standard dependency injection as specified by JSR 330.

===== Lifecycle Management Support

The CometD project provides lifecycle management via the standard
http://jcp.org/en/jsr/detail?id=250[JSR 250] +@PostConstruct+ and
+@PreDestroy+ annotations.
We offer this support for those that do not use a dependency injection container
with lifecycle management such as http://www.springsource.org[Spring].

===== Channel Configuration Support

To initialize channels before they can be actually referenced for
subscriptions, the CometD API provides the
+BayeuxServer.createChannelIfAbsent(String channelId, ConfigurableServerChannel.Initializer... initializers)+
method, which allows you to pass initializers that configure the given channel.
Furthermore, it is useful to have a configuration step for channels that happens
before any subscription or listener addition, for example, to configure
authorizers on the channel (see also <<_java_server_authorizers,the authorizers section>>.

In annotated services, you can use the +@Configure+ annotation on methods:

====
[source,java]
----
@Service("echoService")
public class EchoService
{
    @Inject
    private BayeuxServer bayeux;

    @Configure("/echo")
    public void configure(ConfigurableServerChannel channel)
    {
        channel.setLazy(true);
        channel.addAuthorizer(GrantAuthorizer.GRANT_PUBLISH);
    }
}
----
====

===== Session Configuration Support

Services that extend +org.cometd.server.AbstractService+ have two facility
methods to access the LocalSession and the ServerSession, namely
+getLocalSession()+ and +getServerSession()+.

In annotated services, this is accomplished using the +@Session+ annotation:

====
[source,java]
----
@Service("echoService")
public class EchoService
{
    @Inject
    private BayeuxServer bayeux;

    @org.cometd.annotation.Session
    private LocalSession localSession;

    @org.cometd.annotation.Session
    private ServerSession serverSession;
}
----
====

Fields (or methods) annotated with the +@Session+ annotation are optional;
you can just have the +LocalSession+ field, or only the +ServerSession+ field,
or both or none, depending on whether you need them or not.

You cannot inject Session fields (or methods) with +@Inject+.
This is because the +LocalSession+ object and the +ServerSession+ object are
related, and tied to a particular service instance.
Using a generic injection mechanism could lead to confusion (for example,
using the same sessions in two different services).

===== Listener Configuration Support

For server-side services, methods annotated with +@Listener+ represent
callbacks that are invoked during the server-side processing of the message.

CometD passes a reference to Listener methods to both: 

* The +ServerSession+ half object that sent the message.
* The +ServerMessage+ that the server is processing.

The callback method must have the following signature, or a covariant version of it: 

[cols="1a,1a", options="header"]
|===
| Annotated Style
| Inherited Style

| 
====
[source,java]
----
@Service("echoService")
public class EchoService
{
    @Inject
    private BayeuxServer bayeux;
    @Session
    private ServerSession serverSession;

    @org.cometd.annotation.Listener("/echo")
    public void echo(ServerSession remote, ServerMessage.Mutable message)
    {
        String channel = message.getChannel();
        Object data = message.getData();
        remote.deliver(serverSession, channel, data);
    }
}
----
====

|
====
[source,java]
----
public class EchoService extends AbstractService
{
    public EchoService(BayeuxServer bayeux)
    {
        super(bayeux, "echoService");
        addService("/echo", "echo");
    }

    public void echo(ServerSession remote, ServerMessage.Mutable message)
    {
        String channel = message.getChannel();
        Object data = message.getData();
        remote.deliver(getServerSession(), channel, data);
    }
}
----
====
|===

The callback method can return false to indicate that the processing of
subsequent listeners should not be performed and that the message should
not be published.

===== Subscription Configuration Support

For server-side services, methods annotated with +@Subscription+ represent
callbacks that are invoked during the local-side processing of the message.
The local-side processing is equivalent to the remote client-side processing,
but it is local to the server.
The semantic is very similar to the remote client-side processing, in the sense
that the message has completed the server-side processing and has been published.
When it arrives to the local side the information on the publisher is not
available anymore, and the message is a plain +org.cometd.bayeux.Message+
and not a +org.cometd.bayeux.server.ServerMessage+, exactly as it would happen
for a remote client.

This is a rarer use case (most of the time user code must be triggered with
+@Listener+ semantic), but nonetheless is available.

The callback method must have the following signature: 

====
[source,java]
----
@Service("echoService")
public class EchoService
{
    @Inject
    private BayeuxServer bayeux;
    @Session
    private ServerSession serverSession;

    @org.cometd.annotation.Subscription("/echo")
    public void echo(Message message)
    {
        System.out.println("Echo service published " + message);
    }
}
----
====

===== Annotation Processing

The +org.cometd.annotation.ServerAnnotationProcessor+ class performs annotation processing.

====
[source,java]
----
BayeuxServer bayeux = ...;

// Create the ServerAnnotationProcessor
ServerAnnotationProcessor processor = new ServerAnnotationProcessor(bayeux);

// Create the service instance
EchoService service = new EchoService();

// Process the annotated service
processor.process(service);
----
====

After the +ServerAnnotationProcessor.process()+ method returns, the service has
been processed by injecting the +BayeuxServer+ object and the sessions objects,
by calling initialization lifecycle methods, and by registering listeners and subscribers.

Symmetrically, +ServerAnnotationProcessor.deprocess()+ performs annotation deprocessing,
which deregisters listeners and subscribers, and then calls destruction lifecycle methods
(but does not deinject the +BayeuxServer+ object or session objects).

[[_java_server_services_annotated_client_side]]
===== Client-Side Annotated Services

Like their server-side counterpart, client-side services consist in classes annotated with +@Service+.

CometD introduced client-side services to reduce the boilerplate code required:

[cols="1a,1a", options="header"]
|===
| Annotated Style
| Traditional Style

| 
====
[source,java]
----
@Service
public class Service
{
    @Session
    private ClientSession bayeuxClient;

    @Listener(Channel.META_CONNECT)
    public void metaConnect(Message connect)
    {
        // Connect handling...
    }

    @Subscription("/foo")
    public void foo(Message message)
    {
        // Message handling...
    }
}
----
====

|
====
[source,java]
----
ClientSession bayeuxClient = ...;

bayeuxClient.getChannel(Channel.META_CONNECT).addListener(new ClientSessionChannel.MessageListener()
{
    public void onMessage(ClientSessionChannel channel, Message message)
    {
        // Connect handling...
    }
});

bayeuxClient.handshake();
bayeuxClient.waitFor(1000, BayeuxClient.State.CONNECTED);

bayeuxClient.getChannel("/foo").subscribe(new ClientSessionChannel.MessageListener()
{
    public void onMessage(ClientSessionChannel channel, Message message)
    {
        // Message handling...
    }
});
----
====
|===

===== Dependency Injection and Lifecycle Management Support

The CometD project does not offer dependency injection for client-side services,
but supports lifecycle management via the standard http://jcp.org/en/jsr/detail?id=250[JSR 250]
+@PostConstruct+ and +@PreDestroy+ annotations.
Client-side services usually have a shorter lifecycle than server-side services
and their dependencies are usually injected directly while creating the client-side
service instance.

===== Session Configuration Support

In client-side annotated services, the +@Session+ annotation allows the service
instance to have the +ClientSession+ object injected in a field or method.
Like server-side annotated services, the session field (or method) cannot be
injected with +@Inject+.
This is to allow the maximum configuration flexibility between service instances
and +ClientSession+ instances.

====
[source,java]
----
@Service
public class Service
{
    @org.cometd.annotation.Session
    private ClientSession bayeuxClient;
}
----
====

===== Listener Configuration Support

In client-side annotated services, methods annotated with +@Listener+ represent
callbacks that are called upon receipt of messages on meta channels.
Do not use listener callbacks to subscribe to broadcast channels. 

[cols="1a,1a", options="header"]
|===
| Annotated Style
| Traditional Style

| 
====
[source,java]
----
@Service
public class Service
{
    @Listener(Channel.META_CONNECT)
    public void metaConnect(Message connect)
    {
        // Connect handling...
    }
}
----
====

| 
====
[source,java]
----
bayeuxClient.getChannel(Channel.META_CONNECT).addListener(new ClientSessionChannel.MessageListener()
{
    public void onMessage(ClientSessionChannel channel, Message message)
    {
        // Connect handling...
    }
});
----
====
|===

===== Subscription Configuration Support

In client-side annotated services, methods annotated with +@Subscription+
represent callbacks that are called upon receipt of messages on broadcast channels.

[cols="1a,1a", options="header"]
|===
| Annotated Style
| Traditional Style

| 
====
[source,java]
----
@Service
public class Service
{
    @Listener("/foo/*")
    public void foos(Message message)
    {
       // Message handling...
    }
}
----
====

| 
====
[source,java]
----
bayeuxClient.getChannel("/foo/*").subscribe(new ClientSessionChannel.MessageListener()
{
    public void onMessage(ClientSessionChannel channel, Message message)
    {
        // Message handling...
    }
});
----
====
|===

===== Annotation Processing

The +org.cometd.annotation.ClientAnnotationProcessor+ class does annotation processing.

====
[source,java]
----
ClientSession bayeuxClient = ...;

// Create the ClientAnnotationProcessor
ClientAnnotationProcessor processor = new ClientAnnotationProcessor(bayeuxClient);

// Create the service instance
Service service = new Service();

// Process the annotated service
processor.process(service);

bayeuxClient.handshake();
----
====

Listener callbacks are configured immediately on the +ClientSession+ object,
while subscription callbacks are automatically delayed until the handshake is
successfully completed.
