<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0"
      xmlns="http://docbook.org/ns/docbook"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:xl="http://www.w3.org/1999/xlink">

<info>
<title>The CometD Book</title>

<authorgroup>
<author>
    <personname>
        <firstname>Simone</firstname>
        <surname>Bordet</surname>
    </personname>
</author>
</authorgroup>

<copyright>
    <year>2011</year>
    <holder>The Original Author(s)</holder>
</copyright>

<releaseinfo><?eval ${project.version} ?></releaseinfo>

</info>

<xi:include href="content/preface.xml" />


    <chapter xml:id="installation">
        <info>
            <title>CometD Installation</title>
        </info>

        <section>
            <info>
                <title>Downloading and Installing</title>
            </info>
            <para>
                You can download the CometD distribution from
                <link xl:href="http://download.cometd.org/">http://download.cometd.org</link>.
            </para>
            <para>
                Then unpack the distribution in a directory of your choice:
<screen><![CDATA[
$ tar zxvf cometd-<version>.tgz
$ cd cometd-<version>/
]]>
</screen>
            </para>
            <para>
                The CometD Demos contain:
                <itemizedlist>
                <listitem>
                    <para>
                        Two full chat applications (one developed with Dojo, one with jQuery).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Examples of extensions such as message acknowledgement, reload, timesync and
                        timestamp.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        An example of how to echo private messages to a particular client only.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Clustered Auction demo (using the Oort clustering).
                    </para>
                </listitem>
                </itemizedlist>
            </para>
        </section>

        <section>
            <info>
                <title>Running the Demos</title>
            </info>
            <para>
                To try out the CometD demos shipped with the distribution, you need a <productname>Java</productname>
                Development Kit (JDK) - version 5.0 or later, and either
                <link xl:href="http://maven.apache.org">Maven</link>, version 3 or later, or
                a compliant servlet 2.5 container such as <link xl:href="http://eclipse.org/jetty">Jetty</link>.
            </para>

            <section>
                <info>
                    <title>Running the Demos with Maven</title>
                </info>
                <para>
                    Maven requires you to set up the <code>JAVA_HOME</code> environment variable to point to your
                    JDK installation.
                </para>
                <para>
                    After that, running the CometD demos is very simple.
                    Assuming that <filename>$COMETD</filename> is the CometD installation directory, and that you have the
                    <application>mvn</application> executable in your path:
                    <screen>
$ cd $COMETD
$ cd cometd-demo
$ mvn jetty:deploy-war
                    </screen>
                </para>
                <para>
                    The last command starts an embedded Jetty that listens on port 8080.
                    Now point your browser to <link xl:href="http://localhost:8080">http://localhost:8080</link>,
                    to see the CometD Demos main page.
                </para>
            </section>

            <section>
                <info>
                    <title>Running the Demos with Jetty or Another Servlet Container</title>
                </info>
                <para>
                    In the <filename>$COMETD/cometd-demo/target</filename> directory you can find a deployable WAR
                    file that can be deployed in any servlet container.
                    Refer to the servlet container configuration manual to learn how to deploy the WAR in your servlet
                    container.
                </para>
            </section>
        </section>
    </chapter>

    <chapter xml:id="primer">
        <info>
            <title>CometD Primer</title>
        </info>
        <section>
            <info>
                <title>Preparations</title>
            </info>
            <para>
                Working on a project that uses the CometD API requires some preparation, especially regarding tools,
                that can save you a huge amount of time.
                One tool that should not be missing is <link xl:href="http://getfirebug.com/">Firebug</link>
                (if you're using Firefox for development), or the equivalent for Internet Explorer 8, called
                <link xl:href="http://msdn.microsoft.com/en-us/library/dd565622(VS.85).aspx">Developer Tools</link>.
            </para>
            <para>
                The CometD project is built using <link xl:href="http://maven.apache.org">Maven</link>, and using
                Maven to also build your application is a natural fit.
                This Primer uses Maven as the basis for the setup, build and run of your application, but other build tools can apply the same
                concepts.
            </para>
            <important>
                <info>
                    <title>Windows Users</title>
                </info>
                <para>
                    If you are working in the Windows OS, avoid at all costs using a path that contains spaces,
                    such as "C:\Document And Settings\", as your base path.
                    Use a base path such as "C:\CometD\" instead.
                </para>
            </important>
        </section>
        <section>
            <info>
                <title>Project Setup</title>
            </info>
            <para>
                You can set up the project in two ways: using <xref linkend="primer-maven-way" />
                or <xref linkend="primer-non-maven-way" />.
                For both, you can follow <xref linkend="primer-setup-details" />
                to see how some of the files of the project have been set up.
            </para>

            <section xml:id="primer-maven-way">
                <info>
                    <title>The Maven Way</title>
                </info>
                <para>
                    Setting up a project based on the CometD libraries using Maven is very simple, and uses the
                    Maven <emphasis>archetypes</emphasis>, which create the skeleton of the project, in a style very
                    similar to Rails scaffolding.
                </para>
                <para>
                    Issue the following command from a directory that does <emphasis>not</emphasis> contain a
                    <filename>pom.xml</filename> file (otherwise you will get a Maven error), for example an empty
                    directory:
                    <screen>
$ cd /tmp
$ mvn archetype:generate -DarchetypeCatalog=http://cometd.org
...
Choose archetype:
1: http://cometd.org -> cometd-archetype-dojo-jetty6
2: http://cometd.org -> cometd-archetype-jquery-jetty6
3: http://cometd.org -> cometd-archetype-dojo-jetty7
4: http://cometd.org -> cometd-archetype-jquery-jetty7
5: http://cometd.org -> cometd-archetype-spring-jquery-jetty7
6: http://cometd.org -> cometd-archetype-spring-dojo-jetty7
Choose a number:
                    </screen>
                </para>
                <para>
                    As you can see, there are six archetypes available that build a skeleton application using the
                    Dojo or jQuery JavaScript toolkits, both with the choice of using Jetty 6 or Jetty 7 and Spring.
                    Let's choose Dojo with Jetty 7, which is archetype number 3.
                    The archetype generation requires that you define several properties and generates the application skeleton for you,
                    for example:
                    <screen>
Choose a number: : 3
Define value for property 'groupId': : org.cometd.primers
Define value for property 'artifactId': : dojo-jetty7-primer
Define value for property 'version':  1.0-SNAPSHOT: :
Define value for property 'package':  org.cometd.primers: :
[INFO] Using property: cometdVersion = 2.3.1
[INFO] Using property: jettyVersion = 7.4.4.v20110707
Confirm properties configuration:
groupId: org.cometd.primers
artifactId: dojo-jetty7-primer
version: 1.0-SNAPSHOT
package: org.cometd.primers
cometdVersion: 2.3.1
jettyVersion: 7.4.4.v20110707
 Y: :
...
[INFO] BUILD SUCCESS
                    </screen>
                </para>
                <para>
                    Then:
                    <screen>
$ cd dojo-jetty7-primer/
                    </screen>
                </para>
                <para>
                    The skeleton project has now been created as follows:
                    <screen>
$ tree .
.
|-- pom.xml
`-- src
    `-- main
        |-- java
        |   `-- org
        |       `-- cometd
        |           `-- primers
        |               |-- BayeuxInitializer.java
        |               `-- HelloService.java
        `-- webapp
            |-- WEB-INF
            |   `-- web.xml
            |-- application.js
            `-- index.jsp
                    </screen>
                </para>
                <para>
                    The skeleton project is ready for you to run using the following command:
                    <screen>
$ mvn install jetty:run
...
                    </screen>
                </para>
                <para>
                    Now point your browser at
                    <link xl:href="http://localhost:8080/dojo-jetty7-primer">http://localhost:8080/dojo-jetty7-primer</link>,
                    and you should see this message:
                    <screen>
CometD Connection Succeeded
Server Says: Hello, World
                    </screen>
                </para>
                <para>
                    That's it. You have already written your first CometD application :-)
                </para>
            </section>

            <section xml:id="primer-non-maven-way">
                <info>
                    <title>The Non-Maven Way</title>
                </info>
                <para>
                    The first step is to configure your favorite JavaScript toolkit, in our example Dojo, that
                    the web container must serve. Using the Maven Way, this is obtained automatically by overlaying
                    the CometD Dojo bindings WAR file, <filename>cometd-javascript-dojo-[version].war</filename>,
                    but here you must do it manually.
                    The <filename>cometd-javascript-dojo-[version].war</filename> is located in the
                    <filename>cometd-javascript/dojo/target</filename> directory of the CometD distribution.
                </para>
                <orderedlist>
                    <listitem>
                        <para>
                            Unpack the Dojo toolkit to a directory.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Delete the <filename>dojox/cometd</filename> directory that Dojo provides and replace it
                            with the one contained in the <filename>cometd-javascript-dojo-[version].war</filename>.
                            The content of the <filename>dojox/cometd</filename> directory should be the following:
<screen>
dojox/cometd
|-- ack.js
|-- reload.js
|-- timestamp.js
`-- timesync.js
</screen>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Delete the file <filename>dojox/cometd.js</filename> that Dojo provides and replace it with
                            the one at the same path in the <filename>cometd-javascript-dojo-[version].war</filename>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Add the <filename>org</filename> directory from the
                            <filename>cometd-javascript-dojo-[version].war</filename>, and all its content, at the same
                            level of the <filename>dojox</filename> directory.
                        </para>
                    </listitem>
                </orderedlist>
                <para>
                    The final content, equivalent to that produced by the Maven way, should be like this:
                    <screen>
.
|-- dijit
|-- dojo
|-- dojox
|   |-- cometd
|   |   |-- ack.js
|   |   |-- reload.js
|   |   |-- timestamp.js
|   |   `-- timesync.js
|   `-- cometd.js
|-- org
|   |-- cometd
|   |   |-- AckExtension.js
|   |   |-- ReloadExtension.js
|   |   |-- TimeStampExtension.js
|   |   `-- TimeSyncExtension.js
|   `-- cometd.js
|-- WEB-INF
|   |-- classes
|   |   `-- org
|   |       `-- cometd
|   |           `-- primers
|   |               |-- BayeuxInitializer.class
|   |               `-- HelloService.class
|   |-- lib
|   |   |-- bayeux-api-[version].jar
|   |   |-- cometd-java-common-[version].jar
|   |   |-- cometd-java-server-[version].jar
|   |   |-- jetty-continuation-[version].jar
|   |   |-- jetty-jmx-[version].jar
|   |   |-- jetty-servlets-[version].jar
|   |   `-- jetty-util-[version].jar
|   `-- web.xml
|-- application.js
`-- index.jsp
                    </screen>
                </para>
                <para>
                    The <filename>org</filename> directory contains the new shared CometD implementation and the
                    shared extensions, while the correspondent files in the <filename>dojox</filename> directory are
                    the Dojo <emphasis>bindings</emphasis>.
                    Other bindings exist for the jQuery toolkit, but the shared CometD implementation is the same.
                </para>
                <para>
                    The second step is to configure the server side. If you use Java, this means that you have to
                    set up the CometD servlet that responds to messages from clients.
                    The details of the server side configuration and service development are explained in
                    <xref linkend="java-server" />.
                </para>
                <para>
                    The last step is to write a JSP (or HTML) file that downloads the JavaScript dependencies and
                    the JavaScript application, as explained in the following section.
                </para>
            </section>

            <section xml:id="primer-setup-details">
                <info>
                    <title>Setup Details</title>
                </info>
                <para>
                    The JSP file, <filename>index.jsp</filename>, contains the reference to the JavaScript toolkit
                    dependencies and to the JavaScript application file:
                    <informalexample>
                        <programlisting language="html"><![CDATA[
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <script type="text/javascript" src="${pageContext.request.contextPath}/dojo/dojo.js.uncompressed.js"></script>
    <script type="text/javascript" src="application.js"></script>
    <script type="text/javascript">
        var config = {
            contextPath: '${pageContext.request.contextPath}'
        };
    </script>
</head>
<body>
    ...
</body>
</html>
]]>
                        </programlisting>
                    </informalexample>
                </para>
                <para>
                    It also configures a JavaScript configuration object, <varname>config</varname>, with variables
                    that the JavaScript application might need. This is totally optional.
                </para>
                <para>
                    The JavaScript application, contained in the <filename>application.js</filename> file,
                    configures the <varname>cometd</varname> object and starts the application.
                    The archetypes provide:
                    <informalexample>
                        <programlisting language="javascript">
<xi:include href="https://github.com/cometd/cometd/raw/master/cometd-archetypes/dojo-jetty7/src/main/resources/archetype-resources/src/main/webapp/application.js" parse="text" />
                        </programlisting>
                    </informalexample>
                </para>
                <para>
                    Notice the following:
                    <itemizedlist>
                        <listitem>
                            <para>
                                The use of <code>dojo.addOnLoad()</code> to wait for the document to load up before
                                executing the <varname>cometd</varname> object initialization.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The use of <code>dojo.addOnUnload()</code> to disconnect when the page is
                                refreshed or closed.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The use of the function <code>_metaHandshake()</code> to set up the initial
                                configuration on first contact with the server (or when the server has lost client
                                information, for example because of a server restart).
                                This is totally optional, but highly recommended.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The use of the function <code>_metaConnect()</code> to detect when the communication
                                has been successfully established (or re-established). This is totally optional,
                                but highly recommended.
                            </para>
                            <para>
                                Be warned that the use of the <code>_metaConnect()</code> along with the
                                <varname>_connected</varname> status variable can result in your code (that in this
                                simple example sets the innerHTML property) to be called more than once if,
                                for example, you experience temporary network failures or if the server restarts.
                            </para>
                            <para>
                                Therefore the code that you put in the
                                <code>_connectionEstablished()</code> function must be
                                <link xl:href="http://en.wikipedia.org/wiki/Idempotent">idempotent</link>.
                                In other words, make sure that if the <code>_connectionEstablished()</code>
                                function is called more than one time, it will behave exactly as if it is
                                called only once.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
        </section>

        <section>
            <info>
                <title>Migrating from CometD 1</title>
            </info>
            <section>
                <info>
                    <title>Required JDK Version</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>JDK 1.5</td>
                            <td>JDK 1.5</td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>Java Packages and Classes Migration</title>
                </info>
                <para>
                    In general the API classes and interfaces moved from <classname>org.cometd.*</classname> to
                    <classname>org.cometd.</classname><emphasis role="bold"><classname>bayeux</classname></emphasis><classname>.*</classname>.
                    Server-side implementation classes remained in <classname>org.cometd.server.*</classname>,
                    and client-side implementation classes remained in <classname>org.cometd.client.*</classname>.
                </para>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <classname>org.cometd.*</classname>
                            </td>
                            <td>
                                <classname>org.cometd.</classname>
                                <emphasis role="bold"><classname>bayeux</classname></emphasis>
                                <classname>.*</classname>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <classname>org.cometd.</classname>
                                <emphasis role="bold"><classname>Bayeux</classname></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.bayeux.</classname>
                                <emphasis role="bold"><classname>server.BayeuxServer</classname></emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <classname>org.cometd.</classname>
                                <emphasis role="bold"><classname>Client</classname></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.bayeux.</classname>
                                <emphasis role="bold"><classname>server.ServerSession</classname></emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <classname>org.cometd.</classname>
                                <emphasis role="bold"><classname>Channel</classname></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.bayeux.</classname>
                                <emphasis role="bold"><classname>server.ServerChannel</classname></emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <classname>org.cometd.server.</classname>
                                <emphasis role="bold"><classname>BayeuxService</classname></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.server.</classname>
                                <emphasis role="bold"><classname>AbstractService</classname></emphasis>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>Maven Artifacts Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <classname>org.cometd.java:</classname>
                                <emphasis role="bold"><classname>cometd-api</classname></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.java:</classname>
                                <emphasis role="bold"><classname>bayeux-api</classname></emphasis>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>CometD Servlet Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <classname>org.cometd.server.</classname>
                                <emphasis role="bold"><classname>continuation.ContinuationCometdServlet</classname></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.server.</classname>
                                <emphasis role="bold"><classname>CometdServlet</classname></emphasis>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>CometD Servlet Parameter Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>multiFrameInterval</code>
                            </td>
                            <td>
                                <code>long-polling.multiSessionInterval</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>requestAvailable</code>
                            </td>
                            <td>
                                <code>N/A (always true)</code>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>BayeuxService Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <classname>org.cometd.server.BayeuxService.</classname>
                                <emphasis role="bold"><code>subscribe()</code></emphasis>
                            </td>
                            <td>
                                <classname>org.cometd.server.AbstractService.</classname>
                                <emphasis role="bold"><code>addService()</code></emphasis>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>BayeuxService Method Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>public void method(</code>
                                <emphasis role="bold">
                                    <code>Client c, Message m</code>
                                </emphasis>
                                <code>)</code>
                            </td>
                            <td>
                                <code>public void method(</code>
                                <emphasis role="bold">
                                    <code>ServerSession c, ServerMessage m</code>
                                </emphasis>
                                <code>)</code>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>Channel Retrieval Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>Channel c = bayeux.getChannel(</code>
                                <emphasis role="bold">
                                    <code>"/foo", true</code>
                                </emphasis>
                                <code>)</code>
                            </td>
                            <td>
                                <code>bayeuxServer.</code>
                                <emphasis role="bold">
                                    <code>createIfAbsent("/foo");</code>
                                </emphasis>
                                <?linebreak?>
                                <code>Channel c = bayeuxServer.getChannel(</code>
                                <emphasis role="bold">
                                    <code>"/foo"</code>
                                </emphasis>
                                <code>);</code>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
            <section>
                <info>
                    <title>Constants Migration</title>
                </info>
                <informaltable>
                    <thead>
                        <tr>
                            <th>CometD 1.x</th>
                            <th>CometD 2.x</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>org.cometd.</code>
                                <emphasis role="bold">
                                    <code>Bayeux.ATTRIBUTE</code>
                                </emphasis>
                            </td>
                            <td>
                                <code>org.cometd.bayeux.</code>
                                <emphasis role="bold">
                                    <code>server.BayeuxServer.ATTRIBUTE</code>
                                </emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>org.cometd.</code>
                                <emphasis role="bold">
                                    <code>Bayeux.META_HANDSHAKE</code>
                                </emphasis>
                            </td>
                            <td>
                                <code>org.cometd.bayeux.</code>
                                <emphasis role="bold">
                                    <code>Channel.META_HANDSHAKE</code>
                                </emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>org.cometd.</code>
                                <emphasis role="bold">
                                    <code>Bayeux.META_CONNECT</code>
                                </emphasis>
                            </td>
                            <td>
                                <code>org.cometd.bayeux.</code>
                                <emphasis role="bold">
                                    <code>Channel.META_CONNECT</code>
                                </emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>org.cometd.</code>
                                <emphasis role="bold">
                                    <code>Bayeux.META_SUBSCRIBE</code>
                                </emphasis>
                            </td>
                            <td>
                                <code>org.cometd.bayeux.</code>
                                <emphasis role="bold">
                                    <code>Channel.META_SUBSCRIBE</code>
                                </emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>org.cometd.</code>
                                <emphasis role="bold">
                                    <code>Bayeux.META_UNSUBSCRIBE</code>
                                </emphasis>
                            </td>
                            <td>
                                <code>org.cometd.bayeux.</code>
                                <emphasis role="bold">
                                    <code>Channel.META_UNSUBSCRIBE</code>
                                </emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>org.cometd.</code>
                                <emphasis role="bold">
                                    <code>Bayeux.META_DISCONNECT</code>
                                </emphasis>
                            </td>
                            <td>
                                <code>org.cometd.bayeux.</code>
                                <emphasis role="bold">
                                    <code>Channel.META_DISCONNECT</code>
                                </emphasis>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </section>
        </section>

    </chapter>

    <chapter xml:id="concepts">
        <info>
            <title>CometD Concepts</title>
        </info>
        <para>

        </para>
    </chapter>

<chapter xml:id="javascript">
<info>
    <title>CometD 2 JavaScript Library</title>
</info>
<para>
The CometD 2 JavaScript library is a portable JavaScript implementation with <emphasis>bindings</emphasis> for the major JavaScript toolkits, currently <link xl:href="http://dojotoolkit.org/">Dojo</link> and <link xl:href="http://jquery.com/">jQuery</link>.
This means that the CometD Bayeux JavaScript implementation is written in pure JavaScript with no dependencies on the toolkits, and that the toolkit bindings add the syntactic sugar that makes the Bayeux APIs feel like they are native to the toolkit.
For example, it is possible to refer to the standard <code>cometd</code> object using the following notation:
</para>
<para>
<screen>
// Dojo style
var cometd = dojox.cometd;

// jQuery style
var cometd = $.cometd;
</screen>
</para>
<para>
If you followed the <xref linkend="primer" />, you might have noticed that the skeleton project requires that you reference both the portable implementation, under <code>org/cometd.js</code>, and one binding–for example Dojo's–under <code>dojox/cometd.js</code>. For jQuery, the binding is under <code>jquery/jquery.cometd.js</code>.
The use of the Bayeux APIs from the JavaScript toolkits is almost identical, and the following sections do not refer to a particular toolkit.
Small differences surface only when passing callback functions to the Bayeux API, where Dojo users might like to use <code>dojo.hitch()</code>, while jQuery users might prefer an anonymous function approach.
</para>
<para>
The following sections present details about the JavaScript Bayeux APIs and their implementation secrets.
</para>
<section xml:id="configuration">
<info>
    <title>JavaScript CometD 2 API: Configuring and Initializing</title>
</info>
<para>
After you have set up your skeleton project following the <xref linkend="primer"  />, you may want to fully understand how to customize and configure the parameters that govern the behavior of the Cometd implementation.
</para>
<para>
The complete API is available through a single object prototype named <code>org.cometd.Cometd</code>.
The Dojo toolkit has one instance of this object available under the name <code>dojox.cometd</code>, while for jQuery it is available under the name <code>$.cometd</code>.
This default <code>cometd</code> object has been instantiated and configured with the default values and it has not started any Bayeux communication yet.
Before it can start Bayeux communication it needs a mandatory parameter: the URL of the Bayeux server.
      </para>
      <para>
There are two ways of passing this parameter:
      </para>
      <para>
<screen>
// First style: URL string
cometd.configure('http://localhost:8080/cometd');

// Second style: configuration object
cometd.configure({
    url: 'http://localhost:8080/cometd'
});
</screen>
     </para>
     <para>
The first way is a shorthand for the second way.
However, the second way allows you to pass other configuration parameters, currently:
     </para>
<informaltable>
<thead>
<tr>
  <th>Parameter Name</th>
  <th>Required</th>
  <th>Default Value</th>
  <th>Parameter Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>url</td>
  <td>yes</td>
  <td></td>
  <td>The URL of the Bayeux server this client will connect to.</td>
</tr>
<tr>
  <td>logLevel</td>
  <td>no</td>
  <td>info</td>
  <td>The log level. Possible values are: "warn", "info", "debug". Output to window.console if available.</td>
</tr>
<tr>
  <td>maxConnections</td>
  <td>no</td>
  <td>2</td>
  <td>The maximum number of connections used to connect to the Bayeux server. Change this value only if you know exactly the client's connection limit and what "request queued behind long poll" means.</td>
</tr>
<tr>
  <td>backoffIncrement</td>
  <td>no</td>
  <td>1000</td>
  <td>The number of milliseconds that the backoff time increments every time a connection with the Bayeux server fails. CometD attempts to reconnect after the backoff time elapses.</td>
</tr>
<tr>
  <td>maxBackoff</td>
  <td>no</td>
  <td>60000</td>
  <td>The maximum number of milliseconds of the backoff time after which the backoff time is not incremented further.</td>
</tr>
<tr>
  <td>reverseIncomingExtensions</td>
  <td>no</td>
  <td>true</td>
  <td>Controls whether the incoming extensions are called in reverse order with respect to the registration order.</td>
</tr>
<tr>
  <td>maxNetworkDelay</td>
  <td>no</td>
  <td>10000</td>
  <td>The maximum number of milliseconds to wait before considering a request to the Bayeux server failed.</td>
</tr>
<tr>
  <td>requestHeaders</td>
  <td>no</td>
  <td>{}</td>
  <td>An object containing the request headers to be sent for every Bayeux request (for example, <code>{"My-Custom-Header":"MyValue"}</code>).</td>
</tr>
<tr>
  <td>appendMessageTypeToURL</td>
  <td>no</td>
  <td>true</td>
  <td>Determines whether or not the Bayeux message type (handshake, connect, disconnect) is appended to the URL of the Bayeux server (see above).</td>
</tr>
<tr>
  <td>autoBatch</td>
  <td>no</td>
  <td>false</td>
  <td>Determines whether multiple publishes that get queued up are sent as a batch on the first occasion, without requiring explicit batching.</td>
</tr>
</tbody>
</informaltable>

    <para>
After you have configured the <code>cometd</code> object, the Bayeux communication does not start until you call <code>handshake()</code>, see the <xref linkend="handshake" />.
    </para>
    <para>
Previous users of the JavaScript CometD implementation called a method named <code>init()</code>. This method still exists, and it is a shorthand for calling <code>configure()</code> followed by <code>handshake()</code>.
Follow the advice in the <xref linkend="handshake" /> as it applies as well to <code>init()</code>.
    </para>
    </section>
    <section xml:id="handshake">
                <info>
                    <title>JavaScript CometD 2 API: Handshake</title>
                </info>
                <para>
The call to <code>handshake()</code> (or to <code>init()</code>) initiates the Bayeux communication with the Bayeux server.
                </para>
                <para>
The Bayeux handshake performs two tasks:
<orderedlist>
    <listitem>The client and the server negotiate the type of transport to use.</listitem>
    <listitem>Once the transport is negotiated successfully, the server informs the client with the detailed timings of the requests.</listitem>
</orderedlist>
As with several methods of the JavaScript CometD API, it is an asynchronous method: it returns immediately, well before the Bayeux handshake steps have completed.
                </para>
                <para>
<note> Calling <code>handshake()</code> <emphasis role="bold"> does not</emphasis> mean that you have completed the handshake with the server when <code>handshake()</code> returns.
</note>
</para>
<para>
The handshake might fail for several reasons:
<itemizedlist>
    <listitem>You mistyped the server URL.</listitem>
    <listitem>The transport could not be negotiated successfully.</listitem>
    <listitem>The server denied the handshake (for example, the authentication credentials were wrong).</listitem>
    <listitem>The server crashed.</listitem>
    <listitem>There was a network failure.</listitem>
</itemizedlist>
Therefore it is not a good idea to write this code:
<screen>
// Configure and handshake
cometd.init('http://localhost:8080/cometd');

// Publish to a channel
cometd.publish('/foo', { foo: 'bar' });
</screen>
</para>
<para>
It is not a good idea because there is no guarantee that the call to <code>publish()</code> (which we cover in a later section) can actually succeed in contacting the Bayeux server.
Since the API is asynchronous, you have no way of knowing synchronously (that is, by having <code>handshake()</code> return an error code or by throwing an exception) that the handshake failed.
Even if the handshake succeeds, you may still be "disconnected" from the Bayeux server, for example because the server crashed just after the successful handshake.
Fortunately there is a way to receive notifications about the details of the Bayeux protocol message exchange: by adding listeners to special channels (called <emphasis>meta channels</emphasis>).
This is explained in the <xref linkend="subscriptions" /> section.
</para>
</section>
<section xml:id="subscriptions">
        <info>
           <title>JavaScript CometD 2 API: Subscribing and Unsubscribing</title>
        </info>
        <para>
        The following sections provide information about the CometD 2 API, subscribing and unsubscribing.
        </para>
        <section>
                 <info>
                    <title>Channels</title>
                 </info>
        <para>
The Bayeux specification defines the concept of a channel: it is like a messaging topic where interested parties can subscribe to receive information published onto the channel.
There are three types of channels:
<orderedlist>
    <listitem>meta channels</listitem>
    <listitem>service channels</listitem>
    <listitem>normal channels</listitem>
</orderedlist>
A channel looks like a directory path such as:
<itemizedlist>
    <listitem><code>/meta/connect</code>–A meta channel; all meta channels starts with the prefix <code>/meta/</code></listitem>
    <listitem><code>/service/chat</code>–A service channel; all service channels starts with the prefix <code>/service/</code></listitem>
    <listitem><code>/foo/bar</code>–A normal channel</listitem>
</itemizedlist>
       </para>

<section>
     <info>
         <title>Meta Channels</title>
     </info>
<para>
The Bayeux protocol itself creates meta channels.
It is not possible to subscribe to meta channels: the server replies with an error message. It is possible to listen to meta channels (see below for the difference between <xref linkend="#subscribevslisten" />.
It makes no sense to publish messages to meta channels: only the Bayeux protocol implementation creates and sends messages on meta channels.
Meta channels are useful on the client to listen for error messages like handshake errors (for example because the client did not provide the correct credentials) or network errors (for example to know when the connection with the server has broken or when it has been re-established).
</para>
</section>
<section>
    <info>
        <title>Service Channels</title>
    </info>
    <para>
Service channels are used in the case of request/response style of communication between client and server (as opposed to the publish/subscribe style of communication or normal channels).
While subscribing to service channels yields no errors, this is a no-operation for the server: the server ignores the subscription request.
It is possible to publish to service channels, with the semantic of a communication between a specific client (the one that is publishing the message on the service channel) and the server.
Service channels are useful to implement, for example, private chat messages: in a chat with userA, userB and userC, userA can publish a private message to userC (without userB knowing about it) using service channels.
</para>
</section>
<section>
    <info>
        <title>Normal Channels</title>
    </info>
    <para>
Normal channels have the semantic of a messaging topic and are used in the case of publish/subscribe style of communication.
Usually, it is possible to subscribe to normal channels and to publish to normal channels; this can only be forbidden using a security policy on the Bayeux server or by using <link xl:href="/documentation/2.x/cometd-java/server/authorizers">authorizers</link>.
Normal channels are useful to implement broadcasting of messages to all subscribed clients, for example in case of a stock price change.
</para>
</section>
</section>
<section  xml:id="subscribevslisten">
    <info>
        <title>Subscribers versus Listeners</title>
    </info>
    <para>
The JavaScript CometD API has two APIs to work with channel subscriptions:
<orderedlist>
    <listitem><code>addListener()</code> and the correspondent <code>removeListener()</code></listitem>
    <listitem><code>subscribe()</code> and the correspondent <code>unsubscribe()</code></listitem>
</orderedlist>
</para>
<para>
The <code>addListener()</code> method:
<itemizedlist>
    <listitem>Must be used to listen to meta channel messages.</listitem>
    <listitem>May be used to listen to service channel messages (you may also use <code>subscribe()</code>, but is not recommended).</listitem>
    <listitem>Should not be used to listen normal channel messages (use <code>subscribe()</code> instead).</listitem>
    <listitem>Does not involve any communication with the Bayeux server, and as such can be called before calling <code>handshake().</code></listitem>
    <listitem>Is synchronous: when it returns, you are guaranteed that the listener has been added.</listitem>
</itemizedlist>
</para>
<para>
The <code>subscribe()</code> method:
<itemizedlist>
    <listitem>Must not be used to listen to meta channels messages (otherwise the server will return an error).</listitem>
    <listitem>May be used to listen to service channel messages (you may also use <code>addListener()</code>, which is preferred).</listitem>
    <listitem>Should be used to listen to normal channel messages.</listitem>
    <listitem>Involves a communication with the Bayeux server and as such cannot be called before calling <code>handshake().</code></listitem>
    <listitem>Is asynchronous: it returns immediately, well before the Bayeux server has received the subscription request.</listitem>
</itemizedlist>
</para>
<para>
<note>
Calling <code>subscribe()</code> <emphasis role="bold"> does not</emphasis> mean that you have completed the subscription with the server when <code>subscribe()</code> returns.
</note>
</para>
<para>
Both <code>addListener()</code> and <code>subscribe()</code> return a subscription object that must be passed to, respectively, <code>removeListener()</code> and <code>unsubscribe()</code>:
<screen>
// Some initialization code
var subscription1 = cometd.addListener('/meta/connect', function() { ... });
var subscription2 = cometd.subscribe('/foo/bar/', function() { ... });

// Some de-initialization code
cometd.unsubscribe(subscription2);
cometd.removeListener(subscription1);
</screen>
</para>
<para>
A common use pattern is to handle the subscription code in an idempotent method, like this:
<screen>
var _subscription;

// The idempotent method
function _refresh()
{
    _appUnsubscribe();
    _appSubscribe();
}

function _appUnsubscribe()
{
    if (_subscription)
        cometd.unsubscribe(_subscription);
    _subscription = null;
}

function _appSubscribe()
{
    _subscription = cometd.subscribe('/foo/bar', function() { ... });
}
</screen>
</para>
<para>
The same of course applies also for <code>addListener()/removeListener()</code>.
</para>
<para>
The point is that you have to be careful in your application: to avoid leak functions, or to execute functions more than once, you have to remove your subscriptions (since you could erroneously bind the same callback twice).
See the <xref linkend="primer" /> for a discussion about using idempotent methods.
</para>
<para>
How do <code>subscribe()</code> and <code>unsubscribe()</code> behave in case the Bayeux server is not reachable (due to network failures or because the server crashed)?
In <code>subscribe()</code> the local listener is first added to the list of subscribers for that channel, then the server communication is attempted. If the communication fails, the server will not know that it has to send messages to this client and therefore on the client,  the local listener (although present) will never be invoked.
In <code>unsubscribe()</code>, the local listener is first removed from the list of subscribers for that channel, then the server communication is attempted. If the communication fails, the server still sends the message to the client,  but there is no local listener to dispatch to.
</para>
</section>
<section xml:id="exception">
    <info>
        <title>Listeners and Subscribers Exception Handling</title>
    </info>
<para>
If a listener or subscriber function throws an exception (for example, calls a method on an undefined object), then the error message is logged (at level "debug").
However, there is a way to intercept these errors by defining the global listener exception handler that is invoked every time a listener or subscriber throws an exception:
<screen>
cometd.onListenerException = function(exception, subscriptionHandle, isListener, message)
{
    // Uh-oh, something went wrong, disable this listener/subscriber
    // Object "this" points to the CometD object
    if (isListener)
        this.removeListener(subscriptionHandle);
    else
        this.unsubscribe(subscriptionHandle);
}
</screen>
</para>
<para>
It is be possible to send messages to the server from the listener exception handler.
If the listener exception handler itself throws an exception, this exception is logged at level "info" and the CometD implementation will not break.
Notice that a similar mechanism exists for extensions, see <xref linkend="extensions" />.
</para>
</section>
<section>
    <info>
        <title>Wildcard Subscriptions</title>
    </info>
    <para>
It is possible to subscribe to several channels simultaneously using wildcards:
<screen>
cometd.subscribe("/chatrooms/*", function(message) { ... });
</screen>
</para>
<para>
A single asterisk has the meaning of matching a single channel segment; in the example above it matches channels <code>/chatrooms/12</code> and <code>/chatrooms/15</code>, but not <code>/chatrooms/12/upload</code>.
To match multiple channel segments, use the double asterisk:
<screen>
cometd.subscribe("/events/**", function(message) { ... });
</screen>
With the double asterisk, the channels <code>/events/stock/FOO</code> and <code>/events/forex/EUR</code> match, as well as <code>/events/feed</code> and <code>/events/feed/2009/08/03</code>.
</para>
<para>
The wildcard mechanism works also for listeners, so it is possible to listen to all meta channels as follows:
<screen>
cometd.addListener("/meta/*", function(message) { ... });
</screen>
</para>
<para>
By default, subscriptions to the global wildcards <code>/*</code> and <code>/**</code> result in an error, but you can change this behavior by specifying a custom security policy on the Bayeux server.
You can specify the wildcards only as the last segment of the channel, so these are invalid subscriptions: <code>/**/foo</code> or <code>/foo/*/bar</code>.
</para>
</section>
<section>
    <info>
        <title>Meta Channel List</title>
    </info>
    <para>
These are the meta channels available in the JavaScript CometD implementation:
<itemizedlist>
    <listitem>/meta/handshake</listitem>
    <listitem>/meta/connect</listitem>
    <listitem>/meta/disconnect</listitem>
    <listitem>/meta/subscribe</listitem>
    <listitem>/meta/unsubscribe</listitem>
    <listitem>/meta/publish</listitem>
    <listitem>/meta/unsuccessful</listitem>
</itemizedlist>
</para>
<para>
Each meta channel is notified when the JavaScript CometD implementation handles the correspondent Bayeux message.
The <code>/meta/unsuccessful</code> channel is notified in case of any failure.
</para>
<para>
By far the most interesting meta channel to subscribe to is <code>/meta/connect</code>, because it gives the status of the current connection with the Bayeux server. In combination with <code>/meta/disconnect</code>, you can use it, for example, to display a green "connected" icon or a red "disconnected" icon on the page, depending on the connection status with the Bayeux server.
</para>
<para>
Here is a common pattern using the <code>/meta/connect</code> and <code>/meta/disconnect</code> channels:
<informalexample>
<programlisting language="html"><![CDATA[
var _connected = false;

cometd.addListener('/meta/connect', function(message)
{
    <span class="code-comment">// if (cometd.getStatus() === 'disconnecting' || cometd.getStatus() === 'disconnected')</span>
    if (cometd.isDisconnected()) <span class="code-comment">// Available since 1.1.2</span>
    {
        return;
    }
    var wasConnected = _connected;
    _connected = message.successful;
    if (!wasConnected && _connected)
    {
        <span class="code-comment">// Reconnected</span>
    }
    else if (wasConnected && !_connected)
    {
        <span class="code-comment">// Disconnected</span>
    }
});

cometd.addListener('/meta/disconnect', function(message)
{
    if (message.successful)
    {
        _connected = false;
    }
}
]]>
</programlisting>
</informalexample>
</para>
<para>
One small caveat with the <code>/meta/connect</code> channel is that <code>/meta/connect</code> is also used for polling the server.
Therefore, if a disconnect is issued during an active poll, the active poll is returned by the server and this triggers the <code>/meta/connect</code> listener.
The initial check on the status verifies that is not the case before executing the connection logic.
</para>
<para>
Another interesting use of meta channels is when there is an authentication step during the handshake.
In this case the registration to the <code>/meta/handshake</code> channel can give details about, for example, authentication failures.
</para>
</section>
</section>
<section xml:id="publishing">
     <info>
        <title>JavaScript CometD 2 API: Publishing</title>
     </info>
     <para>
The <code>publish()</code> method allow you to publish data onto a certain channel:
<screen>
cometd.publish('/mychannel', { mydata: { foo: 'bar' } });
</screen>
You cannot (and it makes no sense) to publish to a meta channel, and you can publish to a channel even if you are not subscribed to that channel.
However, you have to handshake before being able to publish.
</para>
<para>
As with other JavaScript CometD API, <code>publish()</code> involves a communication with the server and it is asynchronous: it returns immediately, well before the Bayeux server has received the message.
</para>
<para>
<note>
Calling <code>publish()</code> does not mean that you have published the message when <code>publish()</code> returns.
</note>
</para>
<para>
If you need to publish several messages to different channels, you might want to use <xref linkend="batching" />.
</para>
</section>
<section xml:id="disconnecting">
      <info>
          <title>JavaScript CometD 2 API: Disconnecting</title>
      </info>
      <para>
The JavaScript CometD implementation performs automatic reconnect in case of network or Bayeux server failures.
The reconnect parameters are described in the <xref linkend="configuration" />.
      </para>
<section>
     <info>
         <title>Short Network Failures</title>
     </info>
   <para>
In case of temporary network failures, the client is notified through the <code>/meta/connect</code> channel (see <xref linkend="subscriptions" /> about meta channels) with messages that have the <code>successful</code> field set to false (see also the archetypes in the <xref linkend="primer" /> as an example).
However, the Bayeux server might be able to keep the client's state, and when the network resumes the Bayeux server might behave as if nothing happened.
The client in this case just re-establishes the long poll, but any message the client publishes during the network failure is not automatically re-sent (though it is possible to be notified, through the <code>/meta/publish</code> channel, of the failed publishes).
   </para>
</section>
<section>
     <info>
          <title> Long Network Failures or Server Failures</title>
     </info>
 <para>
If the network failure is long enough, the Bayeux server times out the lost client, and deletes the state associated with it. The same happens when the Bayeux server crashes (except that the state of all clients is lost).
In this case, the reconnection mechanism on the client performs the following steps:
<itemizedlist>
    <listitem>A long poll is re-attempted, but the server rejects it with a <code>402::Unknown client</code> error message.</listitem>
    <listitem>A handshake is attempted, and the server normally accepts it and allocates a new client.</listitem>
    <listitem>Upon the successful re-handshake, a long poll is re-established.</listitem>
</itemizedlist>
If you register with meta channels, be aware of these steps, since a reconnection might involve more than one message exchange with the server.
</para>
</section>
<section>
     <info>
          <title>Disconnecting</title>
     </info>
<para>
Calling the JavaScript CometD API <code>disconnect()</code> results in a message being sent to the Bayeux server, so that it can clean up any state associated with that client.
As with all methods that involve a communication with the Bayeux server, it is an asynchronous method: it returns immediately, well before the Bayeux server has received the disconnect request.
If the server is unreachable (because it is down or because of network failures), the JavaScript CometD implementation stops any reconnection attempt and cleans up any local state.
It is normally safe to ignore if the <code>disconnect()</code> call has been successful or not: the client is in any case disconnected, its local state cleaned up, and if the server has not been reached it eventually times out the client and cleans up any server-side state for that client.
</para>
<para>
<tip>
If you are debugging your application with Firebug, and you shut down the server, you see in the Firebug console the attempts to reconnect.
To stop those attempts,  type in the Firebug command line: <code>dojox.cometd.disconnect()</code> (for Dojo) or <code>$.cometd.disconnect()</code> (for jQuery).
</tip>
</para>
</section>
</section>
<section xml:id="batching">
    <info>
        <title>JavaScript CometD 2 API: Message Batching</title>
    </info>
 <para>
Often an application needs to send several messages to different channels. A naive way of doing it follows:
<screen>
cometd.handshake();

// Warning: non-optimal code
cometd.publish('/channel1', { product: 'foo' });
cometd.publish('/channel2', { notificationType: 'all' });
cometd.publish('/channel3', { update: false });
</screen>
</para>
<para>
You might think that the three publishes leave the client one after the other, but that is not the case.
Remember that <code>publish()</code> is asynchronous (it returns immediately), so the three <code>publish()</code> calls in sequence likely return well before a single byte reaches the network.
The first <code>publish()</code> executes immediately, and the other two are in a queue, waiting for the first <code>publish()</code> to <emphasis>complete</emphasis>.
A <code>publish()</code> is complete when the server receives it, sends back the meta response, and the client receives the meta response for that publish.
When the first <code>publish</code> completes, the second publish is executed and waits to complete. After that, finally the third <code>publish()</code> is executed.
</para>
<para>
If the configuration parameter called <emphasis>autoBatch</emphasis> is set to true, the implementation automatically batches messages that have been queued up.
In the example above, the first <code>publish()</code> executes immediately, and when it completes, the implementation batches the second and third <code>publish()</code> into one request to the server.
The <emphasis>autoBatch</emphasis> feature is interesting for those systems where events received asynchronously and unpredictably, either at a fast rate or in bursts, end up in generating a <code>publish()</code> to the server: in such cases, using the batching API is not effective (as each event would generate only one <code>publish()</code>).
A burst of events on the client generates a burst of <code>publish()</code> to the server, but this mechanism batches them automatically, making the communication more efficient.
</para>
<para>
The queueing mechanism avoids queueing a <code>publish()</code> behind a long poll. If not for this mechanism, the browser would receive three publish requests but it has only two connections available, and one is already occupied by the long poll request. Therefore, the browser might decide to round-robin the publish requests, so that the first publish goes on the second connection which is free and it is actually sent over the network, (remember that the first connection is already busy with the long poll request),  schedule the second publish to the first connection (after the long poll returns), and schedule the third publish again to the second connection, after the first publish returns.
The result is that if you have a long poll timeout of 5 minutes, the second publish request might arrive to the server 5 minutes later than the first and the third publish request.
</para>
<para>
You can optimize the three publishes using batching, which is a way to group messages together so that a single Bayeux message actually carries the three publish messages.
</para>
<para>
<screen>
cometd.handshake();

{
    cometd.publish('/channel1', { product: 'foo' });
    cometd.publish('/channel2', { notificationType: 'all' });
    cometd.publish('/channel3', { update: false });
});

// Alternatively, but not recommended:
cometd.startBatch()
cometd.publish('/channel1', { product: 'foo' });
cometd.publish('/channel2', { notificationType: 'all' });
cometd.publish('/channel3', { update: false });
cometd.endBatch()
</screen>
</para>
<para>
Notice how the three <code>publish()</code> calls are now within a function passed to <code>batch()</code>.
</para>
<para>
Alternatively, but less recommended, you can surround the three <code>publish()</code> calls between <code>startBatch()</code> and <code>endBatch()</code>.
</para>
<para>
<warning>>
Remember to call <code>endBatch()</code> after calling <code>startBatch()</code>.
If you don't, for example because an exception is thrown in the middle of the batch, your messages continue to queue up, and your application will not work as expected.
</warning>
</para>
<para>>
If you still want to risk and use the <code>startBatch()</code> and <code>endBatch()</code> calls, remember that they must be done from the same context of execution; message batching has not been designed to span multiple user interactions.
For example, it would be wrong to start a batch in functionA (triggered by user interaction), and ending the batch in functionB (also triggered by user interaction and not called by functionA).
Similarly, it would be wrong to start a batch in functionA and then schedule (using <code>setTimeout()</code>) the execution of functionB to end the batch.
Function <code>batch()</code> already does the correct batching for you (also in case of errors), so it is the recommended way to do message batching.
</para>
<para>>
When a batch starts, subsequent API calls are not sent to the server, but instead queued up, until the batch ends.
The end of the batch packs up all the queued messages into one single Bayeux message and sends it over the network to the Bayeux server.
</para>
<para>>
Message batching allows efficient use of the network, as instead of making three request/response cycles, batching makes only one request/response cycle.
</para>
<para>
Batches can be made up of different API calls:
<screen>
var _subscription;

(function()
{
    cometd.unsubscribe(_subscription);
    _subscription = cometd.subscribe('/foo', function(message) { ... });
    cometd.publish('/bar', { ... });
});
</screen>
</para>
<para>
The Bayeux server processes batched messages in the order they are sent.
</para>
</section>
<section>
    <info>
        <title>JavaScript CometD 2 Transports</title>
    </info>
    <para>
The <link> xl:href=http://cometd.org/documentation/bayeux/spec">Bayeux specification</link> defines two mandatory transports:
<itemizedlist>
    <listitem>long-polling</listitem>
    <listitem>callback-polling</listitem>
</itemizedlist>
</para>
<para>
The JavaScript CometD implementation implements these two transports and supports also the <link xl:href="http://en.wikipedia.org/wiki/WebSockets">WebSocket</link> transport.
</para>
<para>
<note>
The WebSocket protocol is still an experimental protocol under development by the IETF working group that is standardizing it.
Browsers that have deployed an initial support for the WebSocket protocol might be buggy, so we do not recommend to use the WebSocket protocol yet, though the CometD project supports it.
</note>
</para>
<section>
    <info>
        <title>The <code>long-polling</code> Transport</title>
    </info>
<para>
The <code>long-polling</code> transport is the default transport if the browser and the server do not support WebSockets.
This transport is used when the communication with the Bayeux server happens on the same domain, and also in the cross-domain mode for recent browsers, such as Firefox 3.5+ (see <xref linkend="cross-origin" />).
The data is sent to the server by means of a POST request with Content-Type <code>text/json</code> via a plain XMLHttpRequest call.
</para>
</section>
<section>
    <info>
        <title>The <code>callback-polling</code> Transport</title>
    </info>
    <para>
The <code>callback-polling</code> transport is used when the communication with the Bayeux server happens on a different domain (when the cross-domain mode is not supported, see <xref linkend="cross-origin" />).
</para>
<para>
It is well known that XMLHttpRequest calls have restrictions when the invocation is directed to a domain different from the one to which the script has been downloaded (but see <xref linkend="cross-origin" /> for an alternative solution).
To overcome XMLHttpRequest restrictions, this transport uses the JSONP script injection, which injects a <code>&lt;script&gt;</code> element whose <code>src</code> attribute points to the Bayeux server.
The browser notices the script element injection and performs a GET request to the specified source URL.
The Bayeux server is aware that this is a JSONP request and replies with a JavaScript function that is the browser then executes, (and calls back into the JavaScript Cometd implementation).
</para>
<para>
There are three main drawbacks in using this transport:
<itemizedlist>
    <listitem>The transport is chattier. This is due to the fact that the browser executes the injected scripts sequentially, and until a script has been completely "downloaded", it cannot be executed.
For example, imagine a communication that involves a script injection for the long poll, and a script injection for a message publish. The browser injects the long poll script, a request is made to the Bayeux server, but the Bayeux server holds the request waiting for server-side events (so the "script" is not "downloaded"). Then the browser injects the publish script, the request is made to the Bayeux server, which replies (so the "script is "downloaded"). However, the browser does not execute the second script, because it has not executed the first yet (since its "download" is not finished). In these conditions, the publish would be executed only after the long poll returns. To avoid this situation the Bayeux server, in case of <code>callback-polling</code> transport, resumes the client's long poll for every message that arrives from that client, and that's why the transport is chattier: the long poll returns more often.</listitem>
    <listitem>The message size is limited. This is necessary to support IE7, which has a 2083 character limit for GET requests.</listitem>
    <listitem>The reaction to failures is slower.This is due to the fact that if the script injection points to a URL that returns an error (for example, the Bayeux server is down), this is silently ignored by the browser.</listitem>
</itemizedlist>
</para>
</section>
<section>
    <info>
        <title>The <code>websocket</code> Transport</title>
    </info>
    <para>
The <code>websocket</code> transport is available if the browser and the server supports WebSocket (<link xl:href="http://eclipse.org/jetty">Jetty 7</link> supports the WebSocket protocol).
This transport is still experimental, but it is being designed to be the bidirectional communication protocol for the web, so it is a natural fit in the CometD project.
However, the WebSocket protocol is still in alpha state, and browsers support it to various degrees of reliability, so we do not yet recommend it in production (see <xref linkend="unregistering" /> on how to disable transports).
The websocket transport is disabled by default since CometD 2.1.0, but can be enabled easily, following <link xl:href="http://cometd.org/documentation/2.x/howtos/websocket">Enabling CometD</link>.
</para>
</section>
<section xml:id="unregistering">
    <info>
        <title>Unregistering Transports</title>
    </info>
        <para>
CometD JavaScript transports are added in the JavaScript toolkit <emphasis>bindings</emphasis> for the CometD JavaScript library.
        </para>
        <para>
The CometD JavaScript API allows you to unregister transports, and this can be useful to force the use of only one transport (for example for testing purposes), or to disable certain transports that might be unreliable.
For example, it is possible to unregister the websocket transport by unregistering it with the following code:
</para>
<para>
<screen>
var cometd = dojox.cometd; // Dojo style
var cometd = $.cometd; // jQuery style

cometd.unregisterTransport('websocket');
</screen>
</para>
</section>
<section xml:id="cross-origin">
    <info>
        <title>The cross-domain Mode</title>
    </info>
    <para>
Firefox 3.5 introduced the capability for XMLHttpRequest calls to be performed towards a different domain (see <link xl:href="https://developer.mozilla.org/En/HTTP_access_control">HTTP Access Control</link>).
This is supported also in the JavaScript CometD implementation, with no configuration necessary on the client (if the browser supports XMLHttpRequest cross-domain calls, they will be used) and with a bit of configuration for the server. Refer to <link xl:href="http://wiki.eclipse.org/Jetty/Feature/Cross_Origin_Filter">this document</link> for the server configuration.
    </para>
    <para>
To use the cross-domain mode, you need:
<itemizedlist>
    <listitem>A cross-domain compliant browser (for example Firefox 3.5).</listitem>
    <listitem>A compliant server (for example, Jetty configured with the <code>CrossOriginFilter.</code>)</listitem>
</itemizedlist>
    </para>
    <para>
With this setup, even when the communication with the Bayeux server is cross-domain, the <code>long-polling</code> transport is used, avoiding the drawbacks of the <code>callback-polling</code> transport.
    </para>
    </section>
    </section>
</chapter>
</book>
